<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>–ö–ª–∞–≤–∏—à–Ω—ã–π –°–∏–Ω—Ç–µ–∑–∞—Ç–æ—Ä</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #0f0;
      font-family: monospace;
    }
    canvas {
      width: 100vw;
      height: 30vh;
      display: block;
      background: #111;
    }
    #info {
      padding: 1em;
      font-size: 1em;
      line-height: 1.5;
    }
    #waveformInput {
      width: 100%;
      background: #222;
      color: #0f0;
      border: none;
      font-family: monospace;
      font-size: 1em;
      padding: 0.5em;
    }
  </style>
</head>
<body>
  <canvas id="oscilloscope"></canvas>
  <div id="info">–ù–∞–∂–∏–º–∞–π –∫–ª–∞–≤–∏—à–∏ (z ‚Üí ]). –ü—Ä–æ–±–µ–ª ‚Äî —Å–º–µ–Ω–∞ –≤–æ–ª–Ω—ã. –¶–∏—Ñ—Ä—ã –º–µ–Ω—è—é—Ç baseFreq. Shift ‚Äî FM, Caps ‚Äî –¥–µ—Ç—é–Ω.</div>
  <div id="waveformContainer" style="padding: 1em; background: #111; border-top: 1px solid #0f0; display: none;">
    üßÆ <strong>–§–æ—Ä–º—É–ª–∞ –≥–∞—Ä–º–æ–Ω–∏–∫</strong> (–≤–≤–æ–¥ –æ—Ç <code>n</code>: –≥–∞—Ä–º–æ–Ω–∏–∫–∞ 1,2,...):<br>
    <input id="waveformInput" value="1/(n-(n/1)*Math.sin(n)*20)">
  </div>

<script>
const context = new (window.AudioContext || window.webkitAudioContext)();
const analyser = context.createAnalyser();
analyser.fftSize = 64*8;

const canvas = document.getElementById('oscilloscope');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');

const masterGain = context.createGain();
masterGain.gain.value = 0.7;
masterGain.connect(analyser);
analyser.connect(context.destination);

const waveforms = ['sine', 'square', 'triangle', 'sawtooth', 'custom'];
let waveformIndex = 0;
let waveformType = waveforms[waveformIndex];

const fmModGainLevels = [0.1, 0.5,1, 2, 4, 6, 8,10, 20, 40, 60, 100, 150, 200, 333, 400, 500, 600, 700, 800, 900, 1000, 1200, 1500,3000];
const fmModFreqLevels = [0.1, 0.5,1, 2, 4, 6, 8, 10, 15, 20, 30, 50, 100, 170, 235, 333,400, 500, 600, 700, 800, 900, 1200, 1500, 3000];

let fmModGainIndex = 2;
let fmModFreqIndex = 2;
let fmModGain = fmModGainLevels[fmModGainIndex];
let fmModFreq = fmModFreqLevels[fmModFreqIndex];

const orderedKeys = [
  'z','x','c','v','b','n','m',',','.','/',
  'a','s','d','f','g','h','j','k','l',';','\'','\\',
  'q','w','e','r','t','y','u','i','o','p','[',']'
];

let baseFreq = 130.81;
const keyToFreq = {};
function rebuildKeyMap(baseFreq, semitoneOffset = 0) {
  orderedKeys.forEach((key, index) => {
    const totalSemitone = index + semitoneOffset;
    keyToFreq[key] = baseFreq * Math.pow(2, totalSemitone / 12);
  });
}
rebuildKeyMap(baseFreq);

const orderedModeKeys = ['`','1','2','3','4','5','6','7','8','9','0','-','='];
const baseFreqOptions = [20.00, 40.00, 98.00, 110.00, 130.81, 146.83, 164.81, 196.00, 220.00, 261.63, 293.66, 329.63, 349.23];

const pressedKeys = {};
const activeFrequencies = [];

function calculateAverageFrequency() {
  if (activeFrequencies.length === 0) return 0;
  return activeFrequencies.reduce((a, b) => a + b, 0) / activeFrequencies.length;
}

function drawOscilloscope() {
  requestAnimationFrame(drawOscilloscope);
  const bufferLength = analyser.fftSize;
  const dataArray = new Uint8Array(bufferLength);
  analyser.getByteTimeDomainData(dataArray);

  const width = canvas.width = window.innerWidth;
  const height = canvas.height = window.innerHeight * 0.60;

  ctx.clearRect(0, 0, width, height);
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#0f0';
  ctx.beginPath();

  const sliceWidth = width / bufferLength;
  let x = 0;

  for (let i = 0; i < bufferLength; i++) {
    const v = dataArray[i] / 128.0;
    const y = v * height / 2;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
    x += sliceWidth;
  }
  ctx.stroke();
}
drawOscilloscope();

function createCustomWave(formulaStr) {
  const harmonicCount = 64;
  const real = new Float32Array(harmonicCount);
  const imag = new Float32Array(harmonicCount);
  const formula = Function("n", "return " + formulaStr);

  for (let n = 1; n < harmonicCount; n++) {
    const amp = formula(n);
    real[n] = 0;
    imag[n] = amp;
  }
  return context.createPeriodicWave(real, imag, {disableNormalization: false});
}

function updateFMParameters() {
  for (const key in pressedKeys) {
    const entry = pressedKeys[key];
    if (entry.modOsc && entry.modGain) {
      const t = context.currentTime;
      entry.modOsc.frequency.setValueAtTime(fmModFreq, t);
      entry.modGain.gain.setValueAtTime(fmModGain, t);
    }
  }
}

document.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();

  if (e.code === 'PageUp') {
    fmModFreqIndex = (fmModFreqIndex + 1) % fmModFreqLevels.length;
    fmModFreq = fmModFreqLevels[fmModFreqIndex];
    info.innerHTML = `üîÅ FM —á–∞—Å—Ç–æ—Ç–∞: ${fmModFreq} Hz`;
    updateFMParameters();
    return;
  }
  if (e.code === 'PageDown') {
    fmModFreqIndex = (fmModFreqIndex - 1 + fmModFreqLevels.length) % fmModFreqLevels.length;
    fmModFreq = fmModFreqLevels[fmModFreqIndex];
    info.innerHTML = `üîÅ FM —á–∞—Å—Ç–æ—Ç–∞: ${fmModFreq} Hz`;
    updateFMParameters();
    return;
  }
  if (e.code === 'Insert') {
    fmModGainIndex = (fmModGainIndex + 1) % fmModGainLevels.length;
    fmModGain = fmModGainLevels[fmModGainIndex];
    info.innerHTML = `üéöÔ∏è FM –≥–ª—É–±–∏–Ω–∞: ${fmModGain} Hz`;
    updateFMParameters();
    return;
  }
  if (e.code === 'Delete') {
    fmModGainIndex = (fmModGainIndex - 1 + fmModGainLevels.length) % fmModGainLevels.length;
    fmModGain = fmModGainLevels[fmModGainIndex];
    info.innerHTML = `üéöÔ∏è FM –≥–ª—É–±–∏–Ω–∞: ${fmModGain} Hz`;
    updateFMParameters();
    return;
  }

  if (orderedModeKeys.includes(key)) {
    const index = orderedModeKeys.indexOf(key);
    baseFreq = baseFreqOptions[index];
    const semitoneOffset = e.shiftKey ? 1 : 0;
    rebuildKeyMap(baseFreq, semitoneOffset);
    info.innerHTML = `üéöÔ∏è baseFreq: ${baseFreq.toFixed(2)} Hz (${semitoneOffset ? '+1 –ø–æ–ª—É—Ç–æ–Ω' : '–±–µ–∑ —Å–¥–≤–∏–≥–∞'})`;
    return;
  }

  if (key === ' ') {
    waveformIndex = (waveformIndex + 1) % waveforms.length;
    waveformType = waveforms[waveformIndex];
    info.innerHTML = `üéõ –í–æ–ª–Ω–∞: ${waveformType.toUpperCase()}`;
    document.getElementById('waveformContainer').style.display = (waveformType === 'custom') ? 'block' : 'none';
    return;
  }

  if (!keyToFreq[key] || pressedKeys[key]) return;

  const freq = keyToFreq[key];
  const timeNow = context.currentTime;
  const osc = context.createOscillator();
  const gain = context.createGain();

  let modOsc = null;
  let modGain = null;

  if (e.shiftKey) {
    modOsc = context.createOscillator();
    modGain = context.createGain();
    modGain.gain.value = fmModGain;
    modOsc.frequency.value = fmModFreq;
    modOsc.connect(modGain).connect(osc.frequency);
    modOsc.start(timeNow);
  }

  if (e.getModifierState("CapsLock")) {
    osc.detune.value = (Math.random() - 0.5) * 5;
  }

  osc.frequency.setValueAtTime(freq, timeNow);
  if (waveformType === 'custom') {
    const formulaStr = document.getElementById('waveformInput').value;
    try {
      const customWave = createCustomWave(formulaStr);
      osc.setPeriodicWave(customWave);
    } catch (err) {
      info.innerHTML = `‚ùå –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º—É–ª—ã: ${err}`;
      return;
    }
  } else {
    osc.type = waveformType;
  }

  gain.gain.setValueAtTime(0.0001, timeNow);
  gain.gain.linearRampToValueAtTime(0.2, timeNow + 0.01);
  osc.connect(gain);
  gain.connect(masterGain);
  osc.start(timeNow);

  pressedKeys[key] = { osc, gain, freq, modOsc, modGain };
  activeFrequencies.push(freq);

  const avgFreq = calculateAverageFrequency();
  info.innerHTML = `
    üéπ <strong>–ö–ª–∞–≤–∏—à–∞:</strong> ${key}<br>
    üí† <strong>–ß–∞—Å—Ç–æ—Ç–∞:</strong> ${freq.toFixed(2)} Hz<br>
    üß† <strong>–°—Ä–µ–¥–Ω—è—è:</strong> ${avgFreq.toFixed(2)} Hz<br>
    üåä <strong>–í–æ–ª–Ω–∞:</strong> ${waveformType}<br>
    üîÅ FM: ${fmModFreq} Hz, üéöÔ∏è –≥–ª—É–±–∏–Ω–∞: ${fmModGain} Hz
  `;
});

document.addEventListener('keyup', e => {
  const key = e.key.toLowerCase();
  const entry = pressedKeys[key];
  if (!entry) return;

  const timeNow = context.currentTime;
  entry.gain.gain.cancelScheduledValues(timeNow);
  entry.gain.gain.setValueAtTime(entry.gain.gain.value, timeNow);
  entry.gain.gain.linearRampToValueAtTime(0.0001, timeNow + 1.2);
  entry.osc.stop(timeNow + 1.3);
  if (entry.modOsc) entry.modOsc.stop(timeNow + 1.3);

  delete pressedKeys[key];
  const i = activeFrequencies.indexOf(entry.freq);
  if (i !== -1) activeFrequencies.splice(i, 1);
});
</script>
</body>
</html>
